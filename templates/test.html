<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test Mode - Luge Timing Sequence</title>
    
    <!-- Bootstrap 5 CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    
    <!-- Custom CSS -->
    <style>
        * {
            box-sizing: border-box;
        }
        
        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            max-height: 100vh;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
        }
        
        .main-container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            height: calc(100vh - 2rem);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .test-section {
            background: linear-gradient(45deg, #fff3cd, #ffeaa7);
            border-radius: 12px;
            padding: 1.2rem;
            margin-bottom: 1rem;
            border: 2px solid #ffc107;
            flex-shrink: 0;
        }
        
        .status-display {
            background: linear-gradient(45deg, #28a745, #20c997);
            color: white;
            border-radius: 12px;
            padding: 1.5rem;
            text-align: center;
            margin-bottom: 1rem;
            flex-shrink: 0;
        }
        
        .countdown-display {
            font-size: clamp(2.5rem, 6vw, 4rem);
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
            line-height: 1;
        }
        
        .phase-indicator {
            font-size: clamp(1.1rem, 2.5vw, 1.5rem);
            margin-top: 0.5rem;
        }
        
        .btn-warning {
            background: linear-gradient(45deg, #ffc107, #fd7e14);
            border: none;
            border-radius: 12px;
            padding: clamp(12px, 2vw, 16px) clamp(20px, 4vw, 32px);
            font-weight: bold;
            font-size: clamp(1rem, 2.5vw, 1.1rem);
            min-height: clamp(50px, 8vh, 60px);
            transition: all 0.3s ease;
        }
        
        .btn-warning:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 193, 7, 0.4);
        }
        
        .btn-danger {
            background: linear-gradient(45deg, #dc3545, #c82333);
            border: none;
            border-radius: 12px;
            padding: clamp(12px, 2vw, 16px) clamp(20px, 4vw, 32px);
            font-weight: bold;
            font-size: clamp(1rem, 2.5vw, 1.1rem);
            min-height: clamp(50px, 8vh, 60px);
            transition: all 0.3s ease;
        }
        
        .btn-danger:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(220, 53, 69, 0.4);
        }
        
        .form-range {
            height: clamp(8px, 1.5vh, 12px);
            border-radius: 6px;
            padding: 16px 0; /* Add padding for larger touch target */
            margin: 12px 0; /* Add margin for easier touch interaction */
        }
        
        .form-range::-webkit-slider-thumb {
            background: linear-gradient(45deg, #ffc107, #fd7e14);
            border-radius: 50%;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
            width: clamp(32px, 6vw, 44px);
            height: clamp(32px, 6vw, 44px);
            cursor: pointer;
            -webkit-appearance: none;
            appearance: none;
            transition: all 0.2s ease;
            margin-top: -12px; /* Center the thumb on the track */
        }
        
        .form-range::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(255, 193, 7, 0.4);
        }
        
        .form-range::-webkit-slider-thumb:active {
            transform: scale(1.05);
            box-shadow: 0 2px 8px rgba(255, 193, 7, 0.6);
        }
        
        .offset-value {
            font-size: clamp(1rem, 2.5vw, 1.2rem);
            font-weight: bold;
            color: #fd7e14;
        }
        
        .sequence-progress {
            height: clamp(6px, 1vh, 8px);
            border-radius: 4px;
            background: #e9ecef;
            overflow: hidden;
            margin: clamp(0.5rem, 1.5vh, 1rem) 0;
        }
        
        .progress-bar {
            height: 100%;
            background: linear-gradient(45deg, #28a745, #20c997);
            transition: width 0.3s ease;
        }
        
        .status-idle {
            background: linear-gradient(45deg, #6c757d, #495057);
        }
        
        .status-running {
            background: linear-gradient(45deg, #28a745, #20c997);
        }
        
        .status-gate-open {
            background: linear-gradient(45deg, #ffc107, #fd7e14);
        }
        
        .status-indicator {
            display: inline-block;
            width: clamp(20px, 4vw, 28px);
            height: clamp(20px, 4vw, 28px);
            border-radius: 50%;
            margin: 0 clamp(6px, 1.5vw, 10px);
            background: #6c757d;
            transition: all 0.3s ease;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }
        
        .red-indicator.active {
            background: #dc3545;
            box-shadow: 0 0 15px rgba(220, 53, 69, 0.8);
        }
        
        .yellow-indicator.active {
            background: #ffc107;
            box-shadow: 0 0 15px rgba(255, 193, 7, 0.8);
        }
        
        .green-indicator.active {
            background: #28a745;
            box-shadow: 0 0 15px rgba(40, 167, 69, 0.8);
        }
        
        .current-time-display {
            text-align: center;
            font-size: clamp(0.8rem, 2vw, 1rem);
        }
        
        .test-info {
            background: linear-gradient(45deg, #e3f2fd, #bbdefb);
            border-radius: 8px;
            padding: clamp(1rem, 2vh, 1.5rem);
            margin-bottom: 1rem;
            flex-shrink: 0;
        }
        
        .btn-success {
            background: linear-gradient(45deg, #28a745, #20c997);
            border: none;
            border-radius: 12px;
            padding: clamp(12px, 2vw, 16px) clamp(20px, 4vw, 32px);
            font-weight: bold;
            font-size: clamp(1rem, 2.5vw, 1.1rem);
            min-height: clamp(50px, 8vh, 60px);
            transition: all 0.3s ease;
        }
        
        .btn-success:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(40, 167, 69, 0.4);
        }
        
        .btn-outline-secondary {
            padding: clamp(10px, 2vw, 14px) clamp(18px, 3.5vw, 28px);
            font-size: clamp(0.9rem, 2.2vw, 1rem);
            min-height: clamp(45px, 7vh, 55px);
            border-width: 2px;
            border-radius: 12px;
        }
        
        .form-label {
            font-size: clamp(1rem, 2.2vw, 1.1rem);
            margin-bottom: clamp(0.5rem, 1vh, 0.8rem);
        }
        
        .form-text {
            font-size: clamp(0.85rem, 2vw, 1rem);
        }
        
        /* Responsive container adjustments */
        .container-fluid {
            padding: clamp(0.5rem, 1vw, 1rem);
        }
        
        .main-container {
            max-width: min(95vw, 900px);
            margin: 0 auto;
        }
        
        .row {
            margin: 0;
            height: 100%;
        }
        
        .col-lg-8, .col-xl-6 {
            padding: 0;
            height: 100%;
        }
        
        .d-grid.gap-3 {
            gap: clamp(1rem, 2vh, 1.5rem) !important;
        }
    </style>
</head>
<body>
    <div class="container-fluid">
        <div class="row justify-content-center h-100">
            <div class="col-lg-8 col-xl-6 h-100">
                <div class="main-container p-3 h-100 d-flex flex-column">
                    <!-- Header -->
                    <div class="d-flex align-items-center mb-2 flex-shrink-0">
                        <a href="/" class="btn btn-outline-secondary me-2">
                            ‚Üê Back
                        </a>
                        <div class="text-center flex-grow-1">
                            <h1 class="fw-bold text-warning mb-0" style="font-size: clamp(1.5rem, 4vw, 2.5rem);">Test Mode</h1>
                            <p class="text-muted mb-0" style="font-size: clamp(0.9rem, 2vw, 1.1rem);">Quick alignment testing</p>
                        </div>
                        <div style="width: 80px;"></div> <!-- Spacer for centering -->
                    </div>
                    
                    <!-- Test Info -->
                    <div class="test-info">
                        <h5 class="text-primary mb-2" style="font-size: clamp(1rem, 2.5vw, 1.2rem);">How Test Mode Works</h5>
                        <ul class="mb-0" style="font-size: clamp(0.8rem, 2vw, 1rem);">
                            <li><strong>3 seconds of silence</strong> - Perfect for preparing</li>
                            <li><strong>Final beep plays</strong> - Only the last beep (beep3.wav)</li>
                            <li><strong>Relay activates for 1 second</strong> - With your chosen offset timing</li>
                            <li><strong>Quick testing</strong> - No full sequence needed</li>
                        </ul>
                    </div>
                    
                    <!-- Status Display -->
                    <div id="statusDisplay" class="status-display status-idle flex-shrink-0">
                        <div id="countdownDisplay" class="countdown-display">Ready</div>
                        <div id="phaseIndicator" class="phase-indicator">System Ready</div>
                        
                        <div class="sequence-progress mt-2">
                            <div id="progressBar" class="progress-bar" style="width: 0%"></div>
                        </div>
                        
                        <!-- Current Time Display -->
                        <div class="current-time-display mt-1">
                            <small class="text-white-50">Current Time: <span id="currentTimeDisplay">0.0s</span></small>
                        </div>
                        
                        <!-- Status Indicator Lights -->
                        <div class="mt-2">
                            <span class="status-indicator red-indicator" id="sequenceActiveIndicator" title="Sequence Active"></span>
                            <span class="status-indicator yellow-indicator" id="secondBeepIndicator" title="After Second Beep"></span>
                            <span class="status-indicator green-indicator" id="gateOpenIndicator" title="Gate Open"></span>
                        </div>
                    </div>
                    
                    <!-- Test Controls -->
                    <div class="test-section flex-grow-1 d-flex flex-column">
                        <h3 class="mb-3 text-center" style="font-size: clamp(1.2rem, 3vw, 1.5rem);">Test Configuration</h3>
                        
                        <div class="mb-3">
                            <label for="testOffsetSlider" class="form-label fw-bold">
                                Beep-Relay Offset: <span id="testOffsetValue" class="offset-value">0.0s</span>
                            </label>
                            <input type="range" class="form-range" id="testOffsetSlider" 
                                   min="-2" max="2" step="0.1" value="0.0">
                            <div class="form-text">
                                <strong>Negative values:</strong> Beep plays early (relay happens before beep)<br>
                                <strong>Positive values:</strong> Beep plays late (relay happens after beep)
                            </div>
                        </div>
                        
                        <!-- Control Buttons -->
                        <div class="d-grid gap-2 d-md-flex justify-content-md-center mt-auto">
                            <button id="testModeButton" class="btn btn-warning">
                                Start Test (3s)
                            </button>
                            <button id="saveOffsetButton" class="btn btn-success">
                                Save Offset
                            </button>
                            <button id="stopButton" class="btn btn-danger" style="display: none;">
                                Stop Test
                            </button>
                        </div>
                    </div>
                    
                    <!-- Status Messages -->
                    <div id="statusMessage" class="mt-2" style="display: none;"></div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Bootstrap 5 JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    
    <!-- Test Mode JavaScript -->
    <script>
        // Test Mode Controller
        class TestModeController {
            constructor() {
                this.statusInterval = null;
                this.isRunning = false;
                
                this.initializeElements();
                this.bindEvents();
                this.startStatusPolling();
                this.loadSavedOffset();
            }
            
            initializeElements() {
                // Status elements
                this.statusDisplay = document.getElementById('statusDisplay');
                this.countdownDisplay = document.getElementById('countdownDisplay');
                this.phaseIndicator = document.getElementById('phaseIndicator');
                this.progressBar = document.getElementById('progressBar');
                
                // Status indicators
                this.sequenceActiveIndicator = document.getElementById('sequenceActiveIndicator');
                this.secondBeepIndicator = document.getElementById('secondBeepIndicator');
                this.gateOpenIndicator = document.getElementById('gateOpenIndicator');
                
                // Buttons
                this.testModeButton = document.getElementById('testModeButton');
                this.saveOffsetButton = document.getElementById('saveOffsetButton');
                this.stopButton = document.getElementById('stopButton');
                
                // Test mode elements
                this.testOffsetSlider = document.getElementById('testOffsetSlider');
                this.testOffsetValue = document.getElementById('testOffsetValue');
                this.currentTimeDisplay = document.getElementById('currentTimeDisplay');
            }
            
            bindEvents() {
                // Button events
                this.testModeButton.addEventListener('click', () => this.startTestMode());
                this.saveOffsetButton.addEventListener('click', () => this.saveOffset());
                this.stopButton.addEventListener('click', () => this.stopSequence());
                
                // Test mode events
                this.testOffsetSlider.addEventListener('input', () => this.updateTestOffset());
            }
            
            updateTestOffset() {
                const value = parseFloat(this.testOffsetSlider.value);
                this.testOffsetValue.textContent = value.toFixed(1) + 's';
            }
            
            async saveOffset() {
                const offset = parseFloat(this.testOffsetSlider.value);
                
                try {
                    this.saveOffsetButton.disabled = true;
                    this.saveOffsetButton.textContent = 'Saving...';
                    
                    const response = await fetch('/save_test_offset', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ offset })
                    });
                    
                    const result = await response.json();
                    
                    if (result.success) {
                        this.showNotification('Offset saved successfully!', 'success');
                    } else {
                        this.showNotification(result.message, 'error');
                    }
                } catch (error) {
                    console.error('Error saving offset:', error);
                    this.showNotification('Failed to save offset', 'error');
                } finally {
                    this.saveOffsetButton.disabled = false;
                    this.saveOffsetButton.textContent = 'Save Offset';
                }
            }
            
            async loadSavedOffset() {
                try {
                    const response = await fetch('/get_test_offset');
                    const result = await response.json();
                    
                    if (result.success) {
                        this.testOffsetSlider.value = result.offset;
                        this.updateTestOffset();
                    }
                } catch (error) {
                    console.error('Error loading saved offset:', error);
                }
            }
            
            async startTestMode() {
                if (this.isRunning) {
                    this.showNotification('Test already running!', 'warning');
                    return;
                }
                
                // Get offset from test slider
                const offset = parseFloat(this.testOffsetSlider.value);
                
                try {
                    this.testModeButton.disabled = true;
                    this.testModeButton.textContent = 'Starting Test...';
                    
                    const response = await fetch('/start_test_sequence', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ offset })
                    });
                    
                    const result = await response.json();
                    
                    if (result.success) {
                        this.showNotification('Test started! 3s silence + final beep + relay', 'success');
                        this.isRunning = true;
                        this.updateStatusDisplay('running');
                        this.showStopButton();
                    } else {
                        this.showNotification(result.message, 'error');
                        this.testModeButton.disabled = false;
                        this.testModeButton.textContent = 'Start Test (3s)';
                    }
                } catch (error) {
                    console.error('Error starting test mode:', error);
                    this.showNotification('Failed to start test', 'error');
                    this.testModeButton.disabled = false;
                    this.testModeButton.textContent = 'Start Test (3s)';
                }
            }
            
            async stopSequence() {
                if (!this.isRunning) {
                    this.showNotification('No test running!', 'warning');
                    return;
                }
                
                try {
                    this.stopButton.disabled = true;
                    this.stopButton.textContent = 'Stopping...';
                    
                    const response = await fetch('/stop_sequence', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        }
                    });
                    
                    const result = await response.json();
                    
                    if (result.success) {
                        this.showNotification('Test stopped!', 'success');
                        this.isRunning = false;
                        this.updateStatusDisplay('idle');
                        this.hideStopButton();
                        this.resetStatusIndicators();
                        this.resetCountdown();
                    } else {
                        this.showNotification(result.message, 'warning');
                    }
                } catch (error) {
                    console.error('Error stopping test:', error);
                    this.showNotification('Failed to stop test', 'error');
                } finally {
                    this.stopButton.disabled = false;
                    this.stopButton.textContent = 'Stop Test';
                }
            }
            
            showStopButton() {
                this.testModeButton.style.display = 'none';
                this.stopButton.style.display = 'block';
            }
            
            hideStopButton() {
                this.testModeButton.style.display = 'block';
                this.stopButton.style.display = 'none';
                this.testModeButton.disabled = false;
                this.testModeButton.textContent = 'Start Test (3s)';
            }
            
            startStatusPolling() {
                this.fetchIntervalsAndStartPolling();
            }

            async fetchIntervalsAndStartPolling() {
                try {
                    const resp = await fetch('/get_settings');
                    const cfg = await resp.json();
                    const interval = Math.max(50, parseInt(cfg.auto_refresh_interval || 100));
                    this.statusInterval = setInterval(() => {
                        this.updateSequenceStatus();
                    }, interval);
                } catch (e) {
                    this.statusInterval = setInterval(() => {
                        this.updateSequenceStatus();
                    }, 100);
                }
            }
            
            async updateSequenceStatus() {
                try {
                    const response = await fetch('/sequence_status');
                    const status = await response.json();
                    
                    if (status.running) {
                        this.isRunning = true;
                        this.updateStatusDisplay(status.phase);
                        this.updateCountdown(status);
                        this.updateProgress(status);
                        this.updateStatusIndicators(status);
                    } else {
                        if (this.isRunning) {
                            this.isRunning = false;
                            this.updateStatusDisplay('idle');
                            this.resetStatusIndicators();
                            this.resetCountdown();
                            this.hideStopButton();
                        }
                    }
                } catch (error) {
                    console.error('Error updating status:', error);
                }
            }
            
            updateStatusDisplay(phase) {
                // Remove all status classes
                this.statusDisplay.classList.remove('status-idle', 'status-running', 'status-gate-open');
                
                if (phase === 'idle') {
                    this.statusDisplay.classList.add('status-idle');
                } else if (phase === 'gate_open') {
                    this.statusDisplay.classList.add('status-gate-open');
                } else {
                    this.statusDisplay.classList.add('status-running');
                }
            }
            
            updateCountdown(status) {
                // Update current time display
                this.currentTimeDisplay.textContent = status.current_time ? status.current_time.toFixed(1) + 's' : '0.0s';
                
                if (status.phase === 'test_silence') {
                    const countdown = Math.max(0, status.countdown);
                    this.countdownDisplay.textContent = countdown.toFixed(1);
                    this.phaseIndicator.textContent = 'Test Mode: Silence until final beep';
                } else if (status.phase === 'gate_open') {
                    const countdown = Math.max(0, status.countdown);
                    this.countdownDisplay.textContent = 'GATE OPEN';
                    this.phaseIndicator.textContent = `Gate Open (${countdown.toFixed(1)}s remaining)`;
                } else if (status.phase === 'complete') {
                    this.countdownDisplay.textContent = 'Complete!';
                    this.phaseIndicator.textContent = 'Test Finished - Ready for Next Test';
                } else {
                    this.countdownDisplay.textContent = 'Ready';
                    this.phaseIndicator.textContent = 'System Ready';
                }
            }
            
            updateStatusIndicators(status) {
                const currentTime = status.current_time || 0;
                const timeline = status.timeline;
                
                // Red indicator: Active when sequence is running
                if (status.running) {
                    this.sequenceActiveIndicator.classList.add('active');
                } else {
                    this.sequenceActiveIndicator.classList.remove('active');
                }
                
                // Yellow indicator: Active after second beep (not used in test mode)
                this.secondBeepIndicator.classList.remove('active');
                
                // Green indicator: Active when gate is open
                if (timeline && currentTime >= timeline.gate_open && currentTime < timeline.reset) {
                    this.gateOpenIndicator.classList.add('active');
                } else {
                    this.gateOpenIndicator.classList.remove('active');
                }
            }
            
            resetStatusIndicators() {
                this.sequenceActiveIndicator.classList.remove('active');
                this.secondBeepIndicator.classList.remove('active');
                this.gateOpenIndicator.classList.remove('active');
            }
            
            resetCountdown() {
                this.countdownDisplay.textContent = 'Ready';
                this.phaseIndicator.textContent = 'System Ready';
                this.currentTimeDisplay.textContent = '0.0s';
                this.progressBar.style.width = '0%';
            }
            
            updateProgress(status) {
                if (status.total_time > 0) {
                    const progress = (status.current_time / status.total_time) * 100;
                    this.progressBar.style.width = Math.min(100, progress) + '%';
                }
            }
            
            showNotification(message, type = 'info') {
                // Create notification element
                const notification = document.createElement('div');
                notification.className = `alert alert-${type === 'error' ? 'danger' : type} alert-dismissible fade show position-fixed`;
                notification.style.cssText = 'top: 20px; right: 20px; z-index: 9999; min-width: 300px;';
                notification.innerHTML = `
                    ${message}
                    <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
                `;
                
                document.body.appendChild(notification);
                
                // Auto-remove after 3 seconds
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.remove();
                    }
                }, 3000);
            }
        }
        
        // Initialize the controller when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            window.testController = new TestModeController();
        });
        
        // Handle page visibility changes to pause/resume polling
        document.addEventListener('visibilitychange', () => {
            if (window.testController) {
                if (document.hidden) {
                    // Page is hidden, could pause polling here if needed
                } else {
                    // Page is visible again, ensure polling is active
                    if (!window.testController.statusInterval) {
                        window.testController.startStatusPolling();
                    }
                }
            }
        });
    </script>
</body>
</html>
